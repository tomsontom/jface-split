/******************************************************************************* * Copyright (c) 2006 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation ******************************************************************************/package org.eclipse.jface.menus;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;/** * A node within a menu layout. A node has contains a menu element and some * child nodes. * <p> * This class is only intended to be used from within the * <code>org.eclipse.jface</code> plug-in. * </p> * <p> * <strong>EXPERIMENTAL</strong>. This class or interface has been added as * part of a work in progress. There is a guarantee neither that this API will * work nor that it will remain the same. Please do not use this API without * consulting with the Platform/UI team. * </p> *  * @since 3.2 */final class LayoutNode implements IMenuCollection {	/**	 * The children of this node indexed by their identifiers. This map is	 * lazily initialized, and will be <code>null</code> until someone adds a	 * child node.	 */	private Map childrenById;	/**	 * The element this node represents. This value may be <code>null</code>	 * if this is a top-level node in some menu layout structure, or if the	 * element is implied.	 */	private MenuElement element;	/**	 * The identifiers of the children, but in the order indicating by their	 * ordering constraints. This list is lazily generated.	 */	private List orderedChildIds;	/**	 * Constructs a new <code>SMenuLayout</code>.	 */	LayoutNode() {		// Do nothing	}	public final void add(final int index, final MenuElement element) {		// Force an ordering.		getChildrenSorted();		final String elementId = element.getId();		orderedChildIds.remove(elementId);		if ((index < 0) || (index > size())) {			throw new ArrayIndexOutOfBoundsException("index=" + index //$NON-NLS-1$					+ " and size=" + size()); //$NON-NLS-1$		}		final LayoutNode node = getChildNode(elementId);		node.setElement(element);		orderedChildIds.add(index, elementId);	}	public final void add(final MenuElement element) {		// Force an ordering.		getChildrenSorted();		final String elementId = element.getId();		orderedChildIds.remove(elementId);		final LayoutNode node = getChildNode(elementId);		node.setElement(element);		orderedChildIds.add(elementId);	}	public final void clear() {		childrenById = null;		orderedChildIds = null;	}	public final MenuElement get(final int index) {		final List sortedChildren = getChildrenSorted();		return (MenuElement) sortedChildren.get(index);	}	/**	 * Retrieves the child node with the given identifier. If no such node	 * exists yet, it is created.	 * 	 * @param id	 *            The identifier of the child node to retrieve; must not be	 *            <code>null</code>.	 * @return The child node; never <code>null</code>.	 */	final LayoutNode getChildNode(final String id) {		if (id == null) {			throw new NullPointerException(					"A child node cannot have a null identifier"); //$NON-NLS-1$		}		LayoutNode childNode = null;		if (childrenById == null) {			childrenById = new HashMap(11);		} else {			childNode = (LayoutNode) childrenById.get(id);		}		if (childNode == null) {			childNode = new LayoutNode();			childrenById.put(id, childNode);		}		return childNode;	}	final List getChildrenSorted() {		// TODO A whole whack of work.		return null;	}	/**	 * Returns the children of this node, if any. This collection is unsorted.	 * 	 * @return The children; never <code>null</code>, but may be empty.	 */	final Collection getChildrenUnsorted() {		if (childrenById == null) {			return Collections.EMPTY_LIST;		}		return childrenById.values();	}	/**	 * Returns the menu element for this node.	 * 	 * @return The menu element; may be <code>null</code>.	 */	final MenuElement getMenuElement() {		return element;	}	public final MenuElement remove(final int index) {		final List sortedChildren = getChildrenSorted();		final MenuElement element = (MenuElement) sortedChildren.get(index);		final String id = element.getId();		orderedChildIds.remove(index);		childrenById.remove(id);		return element;	}	public final boolean remove(final MenuElement element) {		final String id = element.getId();		if (orderedChildIds != null) {			orderedChildIds.remove(id);		}		final Object removedObject = childrenById.remove(id);		return (removedObject != null);	}	/**	 * Sets the menu element for this node.	 * 	 * @param element	 *            The element to set; must not be <code>null</code>.	 */	final void setElement(final MenuElement element) {		if (element == null) {			throw new NullPointerException(					"A node cannot be given a null element"); //$NON-NLS-1$		}		this.element = element;	}	public final int size() {		return childrenById.size();	}}